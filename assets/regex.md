# Regular Expression

正则表达式是 `匹配模式`，要么 `匹配字符`，要么 `匹配位置`。

## 位置

表示位置的符号主要有：

^、$、\b、\B、?=p、(?!p)、(?<=p)、(?<!p)

### ^

脱字符，匹配行的开头

### $

美元符号，匹配行的结尾

### \b

单词的边界

### \B

非单词的边界，也就是\b 反着来的意思

### (?=p)

符合 p 子模式前面的那个位置。换句话说是，有一个位置，紧跟其后需要满足 p 子模式。也有一个学名叫**正向先行断言**

### (?!p)

(?=p)反过来的意思，可以理解为(?=p)匹配到的位置之外的位置都是属于(?!p)的，它也有一个学名叫**负向先行断言**

### (?<=p)

符合 p 子模式后面(注意(?=p)表示的是前面)的那个位置。换句话说是，有一个位置，其前面的部分需要满足 p 子模式

### (?<!p)

(?<=p)反过来的意思，可以理解为(?<=p)匹配到的位置之外的位置都是属于(?<!p)的

## 字符串

### 两种模糊匹配

#### 横向

一个正则可匹配的字符串的长度不是固定的，可以是多种情况，通过量词+、\*、?、{m,n}，可实现横向匹配

#### 量词

##### 量词 & 简写

```js
1. {m,} // 至少出现m次
2. {m} // 出现m次
3. ? // 出现0次或者1次，等价于{0,1}
4. + // 至少出现1次,等价于{1,}
5. * // 出现任意次,等价于{0,}
```

##### 贪婪匹配 VS 惰性匹配

正则本身是贪婪的，会尽可能的多匹配符合模式的字符

量词后面加一个？，即变成了惰性匹配

```js
贪婪量词        惰性量词
{m,n}          {m,n}?
{m,}           {m,}?
?              ??
+              +?
*              *?
```

#### 纵向

一个正则匹配的字符串，具体到某一位字符时，可以不是某个确定的字符串，可以有多种可能，实现方式是字符组( 其实多选分支|也可以实现 )

#### 字符组

##### 范围表示法

`[123456abcdefABCDEF] => [1-6a-fA-F]`

##### 排除字符组

某位字符可以是任何东西，但是就是不能是 xxx, 使用^符号

`[^abc]`

##### 常见简写形式

```js
\d // 数字
\D // 非数字
\w // [0-9a-zA-Z_]
\W // [^0-9a-zA-Z_]
\s // [\t\v\n\r\f]
\S // [^\t\v\n\r\f]
.  // 任意字符
```

#### 多选分支

一个模式可以实现横向和纵向的模糊匹配，而多选分支可以支持多个子模式任选其一，形式是(p1|p2|p3)

## 括号

括号的作用是提供了分组（括号内的正则是一个整体，即提供**子表达式**），便于我们引用它

### 分组

让量词作用于一个整体 `()`

### 分支结构

有点像编程里面或的概念|| `(a|b)`

### 分组引用

通过括号创建子表达式，可以进行数据提取和强大的替换操作，也可以通过 js 来引用分组内容

#### 提取数据

```js
/*
提取年月日
2021-08-14
*/

let reg = /(\d{4})-(\d{2})-(\d{2})/;

console.log("2021-08-14".match(reg));
//  ["2021-08-14", "2021", "08", "14", index: 0, input: "2021-08-14", groups: undefined]

// 第二种解法,通过全局的$1...$9读取 引用的括号数据
let reg = /(\d{4})-(\d{2})-(\d{2})/;
let string = "2021-08-14";

reg.test(string);

console.log(RegExp.$1); // 2021
console.log(RegExp.$2); // 08
console.log(RegExp.$3); // 14
```

#### 数据替换

```js
/*
将以下格式替换为mm/dd/yyy
2021-08-14
*/
// 第一种解法
let reg = /(\d{4})-(\d{2})-(\d{2})/;
let string = "2021-08-14";
// 第一种写法
let result1 = string.replace(reg, "$2/$3/$1");
console.log(result1); // 08/14/2021
// 第二种写法
let result2 = string.replace(reg, () => {
  return RegExp.$2 + "/" + RegExp.$3 + "/" + RegExp.$1;
});
console.log(result2); // 08/14/2021
// 第三种写法
let result3 = string.replace(reg, ($0, $1, $2, $3) => {
  return $2 + "/" + $3 + "/" + $1;
});
console.log(result3); // 08/14/2021
```

### 反向引用（很重要）

除了通过 js 引用分组的内容，也可以通过正则来引用分组内容

```js
/*
  写一个正则支持以下三种格式
  2016-06-12
  2016/06/12
  2016.06-12
*/
let regex = /(\d{4})([-/.])\d{2}\2\d{2}/;

var string1 = "2017-06-12";
var string2 = "2017/06/12";
var string3 = "2017.06.12";
var string4 = "2016-06/12";

console.log(regex.test(string1)); // true
console.log(regex.test(string2)); // true
console.log(regex.test(string3)); // true
console.log(regex.test(string4)); // false
```

#### 注意

1. 引用不存在的分组会怎样？

   即匹配的就是\1 \2 本身

2. 分组后面有量词会怎样？

   分组后面如果有量词，分组最终(注意是分组，不是说整体)捕获的数据是最后一次的匹配

```js
'12345'.match(/(\d)+/) // ["12345", "5", index: 0, input: "12345", groups: undefined]

/(\d)+ \1/.test('12345 1') // false
/(\d)+ \1/.test('12345 5') // true
```

### 非捕获性括号

上面使用的括号都会匹配他们匹配到的数据，以便后续引用，所以也可以称为捕获型分组和捕获型分支。

如果想要括号最原始的功能，但不会引用它，也就是既不会出现在 API 引用里，也不会出现在正则引用里，可以使用

非捕获性括号（?:p）

```js
// 非捕获型引用
let reg = /(?:ab)+/g;
console.log("ababa abbb ababab".match(reg)); // ["abab", "ab", "ababab"]
// 注意这里，因为是非捕获型分组，所以使用match方法时，不会出现在数组的1位置了
let reg = /(?:ab)+/;
console.log("ababa abbb ababab".match(reg)); // ["abab", index: 0, input: "ababa abbb ababab", groups: undefined]
let reg = /(ab)+/;
console.log("ababa abbb ababab".match(reg)); // ["abab", "ab", index: 0, input: "ababa abbb ababab", groups: undefined]
```

### 参考

[就因为这三个知识点，我彻底学废了”正则表达式“](https://juejin.cn/post/7021672733213720613)
